Brigit Hawley
CS6300 - Spring 2018
Assignment 5
February 9, 2018

Note: In this application, there are singleton instances of the PlayerListManager, the PuzzleListManager and the TournamentListManager. Only by using the manager specific to the underlying collection type, can a client generate Players, Puzzles and Tournaments respectively. 

1.	By having a PlayerListManager, I have an interface by which new Player objects can be made and managed. If the user wants to login with an already defined Player, the user can select which one by seeing the list of Player names gotten through the PlayerListManager with getExistingPlayersUsernames. This will update the currently currentLoggedInPlayerIndex to point to the correct Player object. If the user wishes to create a new Player, the user can attempt to create a new user with the required information. 
2.	I did not show this in the diagram because this is purely a GUI specification.
3.	I did not consider this requirement because the database will only persist data already present in the design.
4.	The addNewPlayer method in the PlayerListManager will create a new Player object with the requested parameters. If the manager cannot create a new Player object, addNewPlayer will return false, indicating that a Player object already exists with the requested username. Player objects are used to keep track of the data required from users to participate in games. 
5.	By having a PuzzleListManager, I have an interface for managing the Puzzle objects created by Players. Players (in this case considered authors), will give the PuzzleListManager a phrase and a number of max guesses when creating a Puzzle. Additionally, each Puzzle will be associated with the author (Player) that created it based on their username.
6.	Upon the user begins solving a puzzle, one of these PuzzleInProgress objects should be created by the main application. The PuzzleInProgress object needs to know the Player's username who is solving the Puzzle as well as the aforementioned Puzzle. Upon initialization the PuzzleInProgress has a prizeValue of 0, an empty array of guessedLetters, a number of remainingGuessCounts and a flag indicated that the Puzzle has not been solved. 
a.	While the Player tries to solve their current Puzzle, the UI can query the PuzzleInProgress for the puzzlePhrase, the list of unchosenLetters, the accumulated prizeValue and the remainingNumberOfGuesses. 
b.	Each turn the user can update the PuzzleInProgress by:
i.	guessConsonant for a value between 100 and 1000 (generated randomly via the static public method generateMultipleOf100). If the user is correct in their guess, the value will be multiplied by the number of instances of that letter and added to the accumulated prizeValue. The guessed letter will be added to the list of guessedLetters. If the user is incorrect the remainingGuessCount will be decremented.
ii.	buyVowel will decrement the prizeValue by 300. The guessed letter will be added to the list of guessedLetters. If the user is incorrect in their guess, the remainingGuessCount will be decremented. 
iii.	See above i and ii for how the decrement occurs. After calling either guessConsonant or buyVowel, the client should ask the PuzzleInProgress if the Player isOutOfGuesses. If this is the case, the client should request the PuzzleInProgress to generate a PuzzleRecord. During which, the PuzzleInProgress will resetAccumulatedPrizeValue if the Puzzle is not indicated as sovled.
iv.	sovlePuzzle requires the user to enter what they think is the full Puzzle's phrase. If the user is correct, the prizeValue will be properly incremented and the isPuzzleSolved updated. If the user is incorrect, the PuzzleInProgress will resetAccumulatedPrizeValue. Regardless of if the Player is successful, the client should then request the PuzzleInProgress to generate a PuzzleRecord.  
7.	When the Player interrupts a Puzzle, the UI will display a warning message for the user (undocumented here, since that's UI). If the user decides to still exit, the client should ask the PuzzleInProgress to generate a PuzzleRecord. During which, the PuzzleInProgress will resetAccumulatedPrizeValue if the puzzle is not indicated as solved.
8.	When the user requests a new Puzzle, the client can ask the PuzzleListManager for the nextPlayablePuzzleForUser. This will return the next available Puzzle that the Player with the current username has no PuzzleRecord (which indicates it as unplayed). 
9.	The TournamentInProgress class will return the nextUnsolvedPuzzle in the Tournament for the Player's username who is playing the Tournament. This method will return the next Puzzle in the current Tournament that has no PuzzleRecord associated with the current Player. 
10.	Using the TournamentListManager, the user can create new Tournaments. 
a.	By asking the PuzzleListManager for the viableTournamantPuzzles, the client can display the Puzzles played/created by the current Player. The user will select 1-5 of these. The UUIDs for the Puzzle(s) will be given to the TournamentListManager in an attempt to create the Tournament. 
b.	This is not documented as it is a UI component. 
c.	If the given Tournament name is viable, a new Tournament object will be created/maintained by the TournamentListManager. 
11.	Using the TournamentManager the client can do the following for the current Player:
a.	Return a list of newTournamentsForUser. This includes Tournaments not authored by the current Player and contain at least one Puzzle that is playable by the Player (user). Once the Player selects a Tournament a new TournamentInProgress object for the specified Tournament and Player. will be created by the TournamentListManager. This new TournamentInProgress object can return the nextUnsolvedPuzzle. 
b.	Return a list of inProgressTournaments for the current Player. Once the user selects the Tournament they wish to return to, the client can ask the selected TournamentInProgress for the nextUnsolvedPuzzle. 
c.	While the client interacts with each individual Puzzle in the Tournament, the client will be responsible for maintaining a PuzzleInProgress object like specified above in the Puzzle section. While the user is completing Puzzle(s) in the Tournament, the client should be checking areAllPuzzlesComplete. This method will return true once all the Puzzles in the Tournament managed by the current TournamentInProgress object have been completed for the current Player (user). Once this is the case, the client can ask the TournamanetListManager to generateNewTournamentRecord with the current TournamentInProgress object. The TournamentRecord(s) keep track of the completed Tournament's prizeValue (sum of the Puzzle(s)) and which Player completed which Puzzle.
12.	 The user can ask for the following information: 
a.	The PuzzleListManager can return all the PuzzleRecords associated with a specified Player's username. (see getCompletedPuzzlesForUser())
b.	The TournamentListMaanger can return all the TournamentRecords associated with a specified Player's username. (see getCompletedTournamentsForUser ())
c.	The PuzzleListManager can return a list of PuzzleStat(s) that contains the complete list of Puzzles and which Player has the top score for each
d.	The TournamentListManager can return a list of TournamentStat(s) that contains the complete list of Tournaments and which Player has the top score for each
13.	I did not show this in the diagram because this is purely a GUI specification.
14.	Again, did not consider this as part of the diagram because it's a database and memory management specification. 
